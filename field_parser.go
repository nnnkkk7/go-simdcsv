//go:build goexperiment.simd && amd64

//nolint:gosec // G115: Integer conversions are safe - values bounded by buffer size (max ~2GB)
package simdcsv

import (
	"math/bits"
)

// parserState holds state carried between chunks during field parsing
type parserState struct {
	quoted                   bool   // Inside quote state
	fieldStart               uint64 // Current field start offset
	quoteAdjust              uint64 // Length adjustment for quotes
	lastSeparatorOrDelimiter int64  // Last separator position (-1 for initial)
	lastClosingQuote         int64  // Last closing quote position (-1 for invalid)
}

// parseResult represents the result of field parsing (extracted fields and rows)
type parseResult struct {
	fields []fieldInfo // All field information
	rows   []rowInfo   // All row information
}

// fieldInfo holds field position information
type fieldInfo struct {
	start       uint32 // Start offset in buffer (content start, after opening quote if quoted)
	length      uint32 // Field length (content length, excluding quotes)
	rawEndDelta uint8  // Delta from start+length to rawEnd (typically 0-2)
	flags       uint8  // bit0: needsUnescape, bit1: isQuoted (for rawStart calculation)
	// 2 bytes padding
}

const (
	fieldFlagNeedsUnescape = 1 << 0
	fieldFlagIsQuoted      = 1 << 1
)

// rawStart returns the raw start position (including opening quote if quoted)
func (f *fieldInfo) rawStart() uint32 {
	if f.flags&fieldFlagIsQuoted != 0 {
		return f.start - 1
	}
	return f.start
}

// rawEnd returns the raw end position (at separator/newline)
func (f *fieldInfo) rawEnd() uint32 {
	return f.start + f.length + uint32(f.rawEndDelta)
}

// setNeedsUnescape sets the needsUnescape flag
func (f *fieldInfo) setNeedsUnescape(v bool) {
	if v {
		f.flags |= fieldFlagNeedsUnescape
	} else {
		f.flags &^= fieldFlagNeedsUnescape
	}
}

// needsUnescape returns whether the field needs double quote unescaping
func (f *fieldInfo) needsUnescape() bool {
	return f.flags&fieldFlagNeedsUnescape != 0
}

// rowInfo holds row metadata
type rowInfo struct {
	firstField int // First field index in fields array
	fieldCount int // Number of fields in this row
	lineNum    int // Original input line number (for error reporting)
}

// parseBuffer extracts fields and rows from scan result
// This is the main extraction function that processes masks generated by scanBuffer
func parseBuffer(buf []byte, sr *scanResult) *parseResult {
	// Handle empty input
	if len(buf) == 0 || sr.chunkCount == 0 {
		return &parseResult{
			fields: []fieldInfo{},
			rows:   []rowInfo{},
		}
	}

	// Initialize result with estimated capacities
	estimatedFields := len(buf) / avgFieldLenEstimate
	estimatedRows := len(buf) / avgRowLenEstimate
	result := &parseResult{
		fields: make([]fieldInfo, 0, estimatedFields),
		rows:   make([]rowInfo, 0, estimatedRows),
	}

	// Initialize state with lastSeparatorOrDelimiter = -1
	state := parserState{
		lastSeparatorOrDelimiter: -1,
		lastClosingQuote:         -1,
	}
	currentRowFirstField := 0
	lineNum := 1

	// Loop through all chunks, calling processChunkMasks for each
	for chunkIdx := 0; chunkIdx < sr.chunkCount; chunkIdx++ {
		offset := uint64(chunkIdx * simdChunkSize)
		sepMask := sr.separatorMasks[chunkIdx]
		nlMask := sr.newlineMasks[chunkIdx]

		// Get quote mask, default to 0 if not present
		var quoteMask uint64
		if chunkIdx < len(sr.quoteMasks) {
			quoteMask = sr.quoteMasks[chunkIdx]
		}

		// Process this chunk's masks
		processChunkMasks(buf, offset, sepMask, nlMask, quoteMask,
			&state, result, &currentRowFirstField, &lineNum)
	}

	// Handle file without trailing newline
	// Need to finalize if:
	// 1. fieldStart < len(buf) - there's content for a final field
	// 2. fieldStart == len(buf) AND last char is not newline - empty final field after separator
	bufLen := uint64(len(buf))
	lastCharIsNewline := bufLen > 0 && (buf[bufLen-1] == '\n' || buf[bufLen-1] == '\r')
	needsFinalize := state.fieldStart < bufLen ||
		(state.fieldStart == bufLen && !lastCharIsNewline)
	if needsFinalize {
		finalizeLastField(buf, &state, result, currentRowFirstField, lineNum)
	}

	// Mark fields needing double quote unescaping based on chunkHasDQ
	if sr.chunkHasDQ != nil {
		postProcessFields(result, sr.chunkHasDQ)
	}

	return result
}

// processChunkMasks processes one chunk's masks
// Uses bits.TrailingZeros64 to find bit positions and processes
// separator, newline, and quote events in order
func processChunkMasks(
	buf []byte, offset uint64,
	sepMask, nlMask, quoteMask uint64,
	state *parserState, result *parseResult,
	currentRowFirstField, lineNum *int,
) {
	for sepMask != 0 || nlMask != 0 || quoteMask != 0 {
		sepPos := trailingZerosOr64(sepMask)
		nlPos := trailingZerosOr64(nlMask)
		quotePos := trailingZerosOr64(quoteMask)

		minPos := minOfThree(quotePos, sepPos, nlPos)
		if minPos >= 64 {
			break
		}

		switch minPos {
		case quotePos:
			processQuoteEvent(offset+uint64(quotePos), state)
			quoteMask = clearBit(quoteMask, quotePos)

		case sepPos:
			if !state.quoted {
				recordField(buf, offset+uint64(sepPos), state, result, false)
			}
			sepMask = clearBit(sepMask, sepPos)

		default: // nlPos
			if !state.quoted {
				absPos := offset + uint64(nlPos)
				// Check if this is a blank line (no fields recorded yet, empty field)
				isBlankLine := *currentRowFirstField == len(result.fields) && state.fieldStart == absPos
				if isBlankLine {
					// Skip blank line - just advance past the newline
					state.fieldStart = absPos + 1
					state.quoteAdjust = 0
					state.lastClosingQuote = -1
					(*lineNum)++ // Still count the line number
				} else {
					recordField(buf, absPos, state, result, true)
					recordRow(result, currentRowFirstField, lineNum)
				}
			}
			nlMask = clearBit(nlMask, nlPos)
		}
	}
}

// trailingZerosOr64 returns bits.TrailingZeros64 or 64 if mask is 0.
func trailingZerosOr64(mask uint64) int {
	if mask == 0 {
		return 64
	}
	return bits.TrailingZeros64(mask)
}

// clearBit clears the bit at position pos in mask.
func clearBit(mask uint64, pos int) uint64 {
	return mask & ^(uint64(1) << pos)
}

// processQuoteEvent handles a quote character.
func processQuoteEvent(absPos uint64, state *parserState) {
	if !state.quoted {
		// Opening quote: mark that we're inside a quoted field
		// quoteAdjust = 1 means skip 1 byte (the opening quote) when extracting field content
		state.quoted = true
		state.quoteAdjust = 1
	} else {
		// Closing quote: mark end of quoted field
		// Don't increment quoteAdjust - it should remain 1 to only skip the opening quote
		state.quoted = false
		state.lastClosingQuote = int64(absPos)
	}
}

// recordField calculates field bounds and appends to result.
// If isNewline is true, it checks for and excludes a trailing CR (for CRLF handling).
func recordField(buf []byte, absPos uint64, state *parserState, result *parseResult, isNewline bool) {
	start := state.fieldStart + state.quoteAdjust
	endPos := absPos

	// For newline delimiters, check if the previous byte is CR (CRLF sequence)
	// and exclude it from the field content
	if isNewline && endPos > start && endPos > 0 && buf[endPos-1] == '\r' {
		endPos--
	}

	fieldLen := calculateFieldLength(endPos, start, state)

	// Calculate rawEndDelta: absPos - (start + fieldLen)
	rawEndDelta := uint8(0)
	if absPos > start+fieldLen {
		rawEndDelta = uint8(absPos - start - fieldLen)
	}

	// Set flags
	var flags uint8
	if state.quoteAdjust > 0 {
		flags |= fieldFlagIsQuoted
	}

	result.fields = append(result.fields, fieldInfo{
		start:       uint32(start),
		length:      uint32(fieldLen),
		rawEndDelta: rawEndDelta,
		flags:       flags,
	})

	state.fieldStart = absPos + 1
	state.quoteAdjust = 0
	state.lastSeparatorOrDelimiter = int64(absPos)
	state.lastClosingQuote = -1
}

// recordRow appends row info and updates row tracking state
func recordRow(result *parseResult, currentRowFirstField, lineNum *int) {
	fieldCount := len(result.fields) - *currentRowFirstField
	result.rows = append(result.rows, rowInfo{
		firstField: *currentRowFirstField,
		fieldCount: fieldCount,
		lineNum:    *lineNum,
	})
	*currentRowFirstField = len(result.fields)
	(*lineNum)++
}

// calculateFieldLength computes field length, accounting for quoted fields.
// Returns 0 if calculation would result in underflow (invalid state).
func calculateFieldLength(endPos, start uint64, state *parserState) uint64 {
	if state.lastClosingQuote >= 0 && state.quoteAdjust > 0 {
		closeQuote := uint64(state.lastClosingQuote)
		if closeQuote > start {
			return closeQuote - start
		}
		return 0
	}
	if endPos > start {
		return endPos - start
	}
	return 0
}

// finalizeLastField handles the last field when file doesn't end with newline
func finalizeLastField(buf []byte, state *parserState, result *parseResult, currentRowFirstField, lineNum int) {
	start := state.fieldStart + state.quoteAdjust
	bufLen := uint64(len(buf))
	fieldLen := calculateFieldLength(bufLen, start, state)

	// Calculate rawEndDelta: bufLen - (start + fieldLen)
	rawEndDelta := uint8(0)
	if bufLen > start+fieldLen {
		rawEndDelta = uint8(bufLen - start - fieldLen)
	}

	// Set flags
	var flags uint8
	if state.quoteAdjust > 0 {
		flags |= fieldFlagIsQuoted
	}

	result.fields = append(result.fields, fieldInfo{
		start:       uint32(start),
		length:      uint32(fieldLen),
		rawEndDelta: rawEndDelta,
		flags:       flags,
	})

	fieldCount := len(result.fields) - currentRowFirstField
	result.rows = append(result.rows, rowInfo{
		firstField: currentRowFirstField,
		fieldCount: fieldCount,
		lineNum:    lineNum,
	})
}

// postProcessFields marks fields needing double quote unescaping.
// Fields that overlap with chunks marked in chunkHasDQ are flagged.
func postProcessFields(result *parseResult, chunkHasDQ []bool) {
	if len(chunkHasDQ) == 0 {
		return
	}

	for i := range result.fields {
		f := &result.fields[i]

		startChunk := int(uint64(f.start) / simdChunkSize)
		if startChunk < len(chunkHasDQ) && chunkHasDQ[startChunk] {
			f.setNeedsUnescape(true)
			continue
		}

		if f.length > 0 {
			endChunk := int((uint64(f.start) + uint64(f.length) - 1) / simdChunkSize)
			if endChunk != startChunk {
				for c := startChunk; c <= endChunk && c < len(chunkHasDQ); c++ {
					if chunkHasDQ[c] {
						f.setNeedsUnescape(true)
						break
					}
				}
			}
		}
	}
}
